1.make()分配：内部函数 make(T, args) 的服务目的和 new(T) 不同。
2.它只生成切片，映射和程道，并返回一个初始化的（不是零）的，type T的，不是 *T 的值。
3.make() 只用于映射、切片和程道，不返回指针。
4.假如你明确知道当创建的数组切片最多可能需要存储的无素个数为50，那么你设置的存储能力小于50，比如20，那么元素在超过20时，底层将会发生至少一次的内存移动动作。

//分配片结构;* p==零
var p *[]int = new([]int)
*p = make([]int, 100, 100) //这样写有点复杂，很容易就搞乱了
fmt.Println(p)

//现在将V分配一个新的数组，100个整型
//写法一
//var v  []int = make([]int, 100)
//写法二：非常常用的写法，简节明了
 v := make([]int, 100)
fmt.Println(v)


//创建一个初始元素个数为5的数组切片，元素初始值为0
	a := make([]int, 5)  // len(a)=5

//切片有长度和容量。切片的最大长度就是它的容量。
//指定一个切片的容量，通过第三个参数。

//创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间
	b := make([]int, 5, 10)     // len(b)=5, cap(b)=10

//通过重新切片，可使切片增加。
	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

//直接创建并初始化包含5个元素的数组切片
	c := []int{1,2,3,4,5}


